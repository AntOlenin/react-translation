## Как я перестал беспокоиться и полюбил React

[Оригинал статьи](http://firstdoit.com/react-1/)

Если Вы спросите меня, что я думал о [React](https://facebook.github.io/react/docs/getting-started.html) два месяца назад, я бы сказал...

>Где мои шаблоны? Что этот сумасшедший HTML делает в моем JavaScript? JSX выглядит странно! Скорее! Сжечь это!

Это потому что я его не понял.

Но я уверяю, React это определенно правильный путь... Пожалуйста выслушайте меня.


### Старый добрый MVC

Корень зла в интерактивном приложении - это управление состоянием. "Традиционный" подход - MVC архитектура или некоторые ее вариации.

MVC предполагает, что Ваша модель - это единственный источник истины, все состояние живет там. Представления - это производные модели и должны быть синхронизированы. Когда модель изменяется - представления тоже.

В итоге, взаимодействие с пользователем фиксируется контроллером, который обновляет модель. Пока все хорошо.

![](http://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/500px-MVC-Process.svg.png)

Render представления при изменении модели.

Это выглядит довольно просто. Во-первых мы должны описать наше представление - как оно преобразовывает состояние модели в DOM. Затем, всякий раз, когда пользователь что-то делает мы обновляем модель и перерендериваем все... верно? Не так быстро. К сожалению тут не все гладко по 2 причинам:

1. Вообще-то DOM имеет некоторое состояние, такое как содержимое текстовых полей. Если вы перерендериваете ваш DOM полностью это содержимое будет потеряно.

2. DOM операции (такие как удаление и вставка узлов) действительно медленные. Постоянное перерендеривание всего будет вести к ужасной производительности.

Так как же нам держать модель и представления синхронизированными и избежать этих проблем?


### Data binding


За последние 3 года самая распространенная фича фреймворков, введенная для решения этих проблем была data binding.

Data binding - это возможность держать ваши модель и представления синхронизированными автоматически. Обычно в JavaScript это ваши объекты и ваш DOM.

Это достигается через возможность объявить зависимости между кусками данных в вашем приложении. Изменения в состоянии будут распространяться по всему приложению и все зависимости обновятся автоматически.

Давайте посмотрим, как это работает на приктике в некоторых известных фреймворках.


#### Knockout

Knockaut выступает за [MVVM (Model-View-ViewModel) подход](http://knockoutjs.com/documentation/observables.html) и помогает реализовать часть View:

`// View (a template)
<p>First name: <input data-bind="value: firstName" /></p>  
<p>Last name: <input data-bind="value: lastName" /></p>  
<h2>Hello, <span data-bind="text: fullName"> </span>!</h2>

// ViewModel (diplay data... and logic?)
var ViewModel = function(first, last) {  
  this.firstName = ko.observable(first);
  this.lastName = ko.observable(last);

  this.fullName = ko.pureComputed(function() {
      // Knockout tracks dependencies automatically. It knows that fullName depends on firstName and lastName, because these get called when evaluating fullName.
      return this.firstName() + " " + this.lastName();
  }, this);
};`


И вуаля. Изменение значения любого из инпутов будет провоцировать изменение в span. Вы никогда не писали код для его подключения. Классно да?

Но подождите, что насчет того что модель - это единственный источник истины? Откуда ViewModel должна получить свое состояние? Откуда она знает что модель изменилась? Интересные вопросы.

 




 
